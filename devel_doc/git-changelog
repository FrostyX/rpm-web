#!/usr/bin/python3

from functools import cmp_to_key
from textwrap import shorten
import argparse
import re
import subprocess
import sys

from common import shell, KeyType, GitConfig, backports


class PlainLog(object):
    def __init__(self, prev, empty, no_preamble, width, *args, **kwargs):
        self.prev = prev
        self.empty = empty
        self.no_preamble = no_preamble
        self.width = width

    def _preamble(self):
        return RELEASE + ' Changelog'

    def _section(self, section):
        return HEADINGS[section] + '\n'

    def _pull(self, pull):
        fmt = '  * {}{} (#{})'
        prefix, title, num, url = pull
        if prefix:
            prefix = '{}: '.format(HEADINGS[prefix])
        title = shorten(title, self.width - len(fmt.format(prefix, '', num)))
        return fmt.format(prefix, title, num)

    def __str__(self):
        out = []
        if not self.no_preamble:
            out = [self._preamble(), '']
        p = pulls(self.prev)
        last = len(SECTIONS) - 1
        for section in SECTIONS:
            heading = self._section(section)
            if section not in p:
                if self.empty:
                    out.append(heading)
                continue
            out.append(heading)
            for pull in sorted(p[section], key=cmp_to_key(pull_cmp)):
                out.append(self._pull(pull))
            out.append('')
        return '\n'.join(out)

class MarkdownLog(PlainLog):
    def __init__(self, prev, empty, no_preamble, width, level,
                 *args, **kwargs):
        super(MarkdownLog, self).__init__(prev, empty, no_preamble, width)
        self.level = level - 1

    def _heading(self, level, name):
        return '{} {}'.format('#' * (self.level + level), name)

    def _preamble(self):
        return self._heading(1, RELEASE + ' Changelog')

    def _section(self, section):
        return self._heading(2, HEADINGS[section])

    def _pull(self, pull):
        prefix = pull[0]
        if prefix:
            prefix = '*{}:* '.format(HEADINGS[prefix])
        return '* {}{} ([#{}]({}))'.format(prefix, *pull[1:])

def pull_cmp(pull1, pull2):
    prefixes = PREFIXES + ['']
    prefix1 = prefixes.index(pull1[0])
    prefix2 = prefixes.index(pull2[0])
    title1 = pull1[1]
    title2 = pull2[1]
    if prefix1 < prefix2:
        return -1
    elif prefix1 == prefix2:
        if title1 < title2:
            return -1
        else:
            return 1
    else:
        return 1

def pulls(branch):
    pulls = {}
    nums = set()
    ignore = set(IGNORE)

    for commit in backports(branch):
        opts = ''
        if args.refresh:
            opts += '-r '
        if args.quiet:
            opts += '-q '
        lines = shell('git changeset {} {}'.format(opts, commit), split=True)
        if not lines:
            continue
        title = lines[0].split(':', 1)[1].strip()
        labels = set([label.lower() for label in lines[1].split(' ')])
        url = lines[2]

        num = lines[0].split(':')[0][4:]
        if num in nums:
            continue
        nums.add(num)

        for p in PREFIXES:
            if p in labels:
                prefix = p
                break
        else:
            prefix = ''

        labels = set(map(lambda x: ALIASES[x] if x in ALIASES else x, labels))
        if labels & ignore:
            continue
        labels = labels & HEADINGS.keys()
        if not labels:
            labels = set(['other'])

        for label in labels:
            pulls.setdefault(label, []).append((prefix, title, num, url))

    return pulls


CONFIG = GitConfig('changelog')
RELEASE = shell("git tag -l --format='%(contents)' $(git describe --abbrev=0)")
SECTIONS = CONFIG.get('sections', KeyType.LIST)
PREFIXES = CONFIG.get('prefixes', KeyType.LIST)
IGNORE = CONFIG.get('ignore', KeyType.LIST)
HEADINGS = CONFIG.get('headings', KeyType.MAP)
ALIASES = CONFIG.get('aliases', KeyType.MAP)

parser = argparse.ArgumentParser(
    description='Generate a changelog for the last tag based on changesets.')
parser.add_argument('prev', type=str, help='previous tag')
parser.add_argument('-e', '--empty', action='store_true',
                    help='include empty sections')
parser.add_argument('-n', '--no-preamble', action='store_true',
                    help='don\'t include preamble')
parser.add_argument('-m', '--markdown', action='store_true',
                    help='output in Markdown format')
parser.add_argument('-w', '--width', type=int, default=80,
                    help='maximum line width in plain-text mode '
                         '(default: 80)')
parser.add_argument('-l', '--level', type=int, default=1,
                    help='first heading level in Markdown format '
                         '(default: 1)')
parser.add_argument('-r', '--refresh', action='store_true',
                    help='always fetch changeset data from server '
                         '(do not use cache)')
parser.add_argument('-q', '--quiet', action='store_true',
                    help='do not print progress messages on stderr')
args = parser.parse_args()

if args.markdown:
    Log = MarkdownLog
else:
    Log = PlainLog

log = Log(args.prev, args.empty, args.no_preamble, args.width, args.level)
print(log)

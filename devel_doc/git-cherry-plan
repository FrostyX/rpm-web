#!/bin/bash

PROGRAM=cherry-plan
CONFIG=cherryPlan
HEAD=$(git rev-parse --abbrev-ref HEAD)
ABBREV=$(git rev-parse --short HEAD | tr -d '\n' | wc -c)
DIR=$(git config --get $CONFIG.directory); DIR=${DIR:+$DIR/}
SUBJECT="# Rebase"
README="\
#
# Commands:
# pick <commit> = use commit
# drop <commit> = remove commit, not suitable
# noop <commit> = remove commit, already applied
#      <commit> = remove commit, not reviewed yet
#
# These lines MUST NOT be re-ordered; they are executed from top to bottom.
#
# vim:syntax=gitrebase"

usage() {
    echo "\
Usage: git $PROGRAM <command> [<args>]

Manage persistent rebase-like todo lists (\"plans\") to cherry-pick commits.

Useful for crafting larger cherry-pick batches and collaborating on them, e.g.
when preparing a stable release from a development branch.

This tool produces an equivalent of

    git rebase -i HEAD <branch>

with the following differences:

    * standalone file (can be shared, tracked in git, etc.)
    * incremental (always applies to HEAD, no rewriting of history)
    * includes already applied commits for more context (\"noop\" marker)
    * supports the empty marker (to indicate unreviewed commits)

Commands:
    make <branch> [<file>]
                    create plan for current branch with commits on <branch>,
                    save to <file>
    pull <branch> [<file>]
                    append new commits on <branch> to plan <file>, print them
                    on stdout
    update [<file>]
                    mark applied commits in plan <file>
    apply [<file>]  apply plan <file> to current branch

Argument defaults:
    <file>          <current-branch>.plan

Configuration:
    $CONFIG.directory
                    where to save plan <file> if unspecified, default: \$PWD
    $CONFIG.portedRegex
                    pattern to extract original commit hash from commit message
                    of ported commit, set this to mark ported commits as
                    applied
"
    exit 1
}

get_file() {
    echo ${1:-$DIR$HEAD.plan}
}

fail_exists() {
    if [ -f $1 ]; then
        echo "File $1 already exists" >&2
        exit 1
    fi
}

fail_missing() {
    if [ ! -f $1 ]; then
        echo "File $1 not found" >&2
        exit 1
    fi
}

abbrev() {
    cut -c -$ABBREV
}

log() {
    git rev-list --reverse --no-commit-header --pretty="format:     %h %s" $1
}

get_applied() {
    local pattern

    # identical patches
    grep -f <(git rev-list $1.. | git diff-tree -p --stdin | \
              git patch-id | cut -d' ' -f1) \
            <(git rev-list ..$1 | git diff-tree -p --stdin | \
              git patch-id) | cut -d' ' -f2

    # ported patches
    pattern=$(git config --get $CONFIG.portedRegex) || return
    git rev-list --pretty="format:%b" $1.. | sed -n "s/$pattern/\1/p"
}

mark() {
    get_applied $1 | while read line; do
        sed -i "s/^.....\($(echo $line | abbrev)\)/noop \1/" $2
    done
}

subject() {
    local head=$(git rev-parse HEAD | abbrev)
    local range=$head..$(get_last $1)
    local count=$(git rev-list --count $range)
    local text="$SUBJECT $range onto $head ($count commands)"

    if grep -q "^$SUBJECT" $1; then
        sed -i "s/^$SUBJECT .*\$/$text/" $1
    else
        echo $text >> $1
    fi
}

get_hash() {
    sed 's/^.....//' | cut -d' ' -f1
}

get_last() {
    sed '/^#/d; /^$/d' $1 | tail -1 | get_hash
}

get_branch() {
    sed -n "s/^$SUBJECT .*\.\.\(.*\) onto .*\$/\1/p" $1
}

CMD=$1; shift

if [ "$CMD" == "make" ]; then
    [ "$#" -lt 1 ] && usage
    branch=$1
    file=$(get_file $2)
    fail_exists $file

    log HEAD..$branch > $file
    mark $branch $file

    echo >> $file
    subject $file
    echo "$README" >> $file
    echo $file

elif [ "$CMD" == "pull" ]; then
    [ "$#" -lt 1 ] && usage
    branch=$1
    file=$(get_file $2)
    fail_missing $file
    last=$(get_last $file)

    log $last..$branch | tee >(sed -i "/^.....$last/ r /dev/stdin" $file)
    subject $file

elif [ "$CMD" == "update" ]; then
    file=$(get_file $1)
    fail_missing $file
    branch=$(get_branch $file)

    mark $branch $file
    subject $file

elif [ "$CMD" == "apply" ]; then
    file=$(get_file $1)
    fail_missing $file
    grep '^pick ' $file | get_hash | xargs git cherry-pick -x

else
    usage
fi
